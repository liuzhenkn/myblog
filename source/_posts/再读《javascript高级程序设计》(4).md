---
title: 再读《JavaScript高级程序设计》(4)
date: 2017-02-23 00:00:00
tags:
- JavaScript
- 读书笔记
---

### 前言
本篇主要总结第七章-函数表达式的内容，虽然第七章内容不多，但是涉及到几个比较重要的概念-闭包、this，自己也会结合自己以前看过的文章进行总结。

<!-- more -->

### 第七章 函数表达式

##### 函数表达式
定义函数的方式有两种-函数声明和函数表达式，函数声明有一个特性就是函数声明提升，即执行代码的时候会优先读取函数声明，所以函数调用在函数声明之前都是可以的。

##### 递归
JavaScript中的递归很有意思，因为函数中存在arguments.callee指针指向正在执行的函数，这样我们就可以通过调用它来实现递归。例如：
```
function factorial(num){
  if(num<=1){
    return 1;
  }else{
    return num * arguments.callee(num-1);
  }
}
```

##### 闭包
闭包一直是一个让人头晕的概念，我自己也是看过很多相关文章，我觉得理解闭包首先要知道这么几点：什么是闭包？为什么要使用闭包(使用场景)？闭包的原理是什么？使用闭包的优缺点？
(1)什么是闭包？
按照书上的定义： 闭包是有权访问另一个函数作用于中的变量的函数。
而我喜欢这种说法： 函数嵌套函数，内部函数可以引用外部函数的变量，并使其一直保存在内存中。
```
function test(){
  var a = 1;
  console.log(a);
  a++;
}
test();// 1
test();// 1

function test1(){
  var a = 1;
  return function(){
    console.log(a);
    a++;
  };
}
var test2 = test1();
test2();// 1
test2();// 2
```
正常情况下，函数执行完后，其内部变量会被销毁，即a被销毁了，每一次执行都会重新定义，所以每次执行的结果都是1，而第二种情况，是使用了闭包，在内部函数中引用了外部函数的变量，导致其不能被销毁，一直存在于变量中，所以a每次都会在原来的基础上加1。

##### 闭包的原理是什么？如何实现的？
正常情况下，当某个函数被调用时，会创建一个执行环境及其相关的作用域链(详细的到第四章看)，然后使用arguments对象和其他命名参数的值来初始化函数的 **活动对象(AO)**，后台的每一个执行环境都有一个表示变量的对象——**变量对象(VO)**(我理解为活动对象就是在活动的变量对象，两者其实是一个东西),全局环境的变量对象始终存在，而局部环境的变量对象只在函数执行过程中存在。作用域链本质上就是一个指向变量对象的指针列表。所以一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域。
而对于闭包来言，在另一个函数中定义的函数会将外部函数的活动对象添加到他的作用域链中。我们返回的匿名函数的作用域链一直引用着外部函数的活动对象，从而使其活动对象一直保存在内存中。
(基本都是个人理解，觉得对AO和VO不理解的可参考其他博客，有很多讲AO和VO的)
注意： 闭包只能取得外部函数中任何变量的最后一个值，因为闭包所保存的是整个变量对象。
```
function test(){
  var result = [];
  for(var i=0;i < 10;i++){
    result[i] = function(){
      return i;
    };
  }
  return result;
}
```
这里result中的值均为10，因为每个匿名函数的作用域链中都保存着test的活动对象，引用的是同一个i值，当test函数执行完后，i的值应该是10。解决方法：
```
function test(){
  var result = [];
  for(var i=0;i < 10;i++){
    result[i] = function(num){
      return num;
    }(i);
  }
  return result;
}
```
定义了一个匿名函数，并将立即执行该匿名函数的结果赋值给数组。
##### 闭包的使用场景及优缺点
- 希望一个变量长期存在于内存中
- 避免全局变量的污染(不太理解)
- 私有变量
注意问题：
内存泄漏，我理解是变量都保留在了内存中，不能得到释放，损耗性能。

##### this对象
this一直是一个很乱的问题，也有很多人问过我到底this指向的是什么，我个人判别一直是如果有明确被对象调用就是指向该对象，否则就是window对象。
